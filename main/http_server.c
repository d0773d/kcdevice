/**
 * @file http_server.c
 * @brief HTTPS web server implementation
 */

#include "http_server.h"
#include "esp_log.h"

static const char *TAG = "HTTP_SERVER";

#ifndef CONFIG_IDF_TARGET_ESP32C6
// Full HTTP server implementation for ESP32-S3

#include "cloud_provisioning.h"
#include "wifi_manager.h"
#include "time_sync.h"
#include "api_key_manager.h"
#include "web_file_editor.h"
#include "esp_https_server.h"
#include "esp_heap_caps.h"
#include "esp_timer.h"
#include "esp_wifi.h"
#include "esp_ota_ops.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "cJSON.h"
#include "nvs_flash.h"
#include "nvs.h"
#include <string.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <dirent.h>

static httpd_handle_t s_server = NULL;

#define OTA_UPLOAD_BUFFER_SIZE 4096

// External sensor reading functions from mqtt_telemetry.c
extern float read_temperature(void);
extern float read_humidity(void);
extern float read_soil_moisture(void);
extern float read_light_level(void);
extern float read_battery_level(void);

// Sensor manager functions
#include "sensor_manager.h"
#include "ezo_sensor.h"
#include "ezo_sensor.h"
#include "max17048.h"
#include "mqtt_telemetry.h"  // For MAX_SENSOR_VALUES

// Declare embedded web files (generated by CMake)
extern const uint8_t index_html_start[] asm("_binary_index_html_start");
extern const uint8_t index_html_end[]   asm("_binary_index_html_end");

#define SENSOR_CALIBRATE_URI   "/api/sensors/calibrate/"
#define SENSOR_COMP_URI        "/api/sensors/compensate/"
#define SENSOR_MODE_URI        "/api/sensors/mode/"
#define SENSOR_POWER_URI       "/api/sensors/power/"
#define SENSOR_STATUS_URI      "/api/sensors/status/"
#define SENSOR_SAMPLE_URI      "/api/sensors/sample/"
#define SENSOR_WS_URI          "/ws/sensors"

#define SENSOR_WS_MAX_CLIENTS  4
#define FOCUS_SAMPLE_INTERVAL_MS 2500

typedef struct {
    bool should_resume;
    bool mutex_acquired;
} sensor_read_guard_t;

static SemaphoreHandle_t s_sensor_guard_mutex = NULL;

typedef struct {
    int fd;
    bool active;
} sensor_ws_client_t;

static sensor_ws_client_t s_ws_clients[SENSOR_WS_MAX_CLIENTS];
static SemaphoreHandle_t s_ws_clients_mutex = NULL;
static esp_timer_handle_t s_focus_timer = NULL;
static bool s_focus_stream_active = false;
static uint8_t s_focus_sensor_address = 0;
static bool s_focus_paused_readings = false;

static void sensor_read_guard_acquire(sensor_read_guard_t *guard);
static void sensor_read_guard_release(sensor_read_guard_t *guard);
static void handle_sensor_cache_update(const sensor_cache_t *cache, void *ctx);
static cJSON *create_sensors_object_from_cache(const sensor_cache_t *cache);
static void sensor_ws_broadcast_json(const char *json, size_t len);
static void sensor_ws_send_status_event(const sensor_cache_t *cache);
static void sensor_ws_send_focus_sample(ezo_sensor_t *sensor, const float *values, uint8_t count);
static void sensor_ws_send_focus_status(const char *status, uint8_t address);
static esp_err_t sensor_ws_handler(httpd_req_t *req);
static void handle_ws_command(int client_fd, const char *payload, size_t len);
static void focus_timer_cb(void *arg);
static void focus_stream_sample_now(void);
static esp_err_t focus_stream_start(uint8_t address);
static void focus_stream_stop(void);
static void sensor_ws_remove_client(int fd);
static cJSON *build_sensor_json(ezo_sensor_t *sensor, int index, bool include_runtime);
static void add_sample_readings_to_json(cJSON *json, const char *type, const float values[], uint8_t count);
static ezo_sensor_t *find_sensor_by_address(uint8_t address);

static void sensor_read_guard_acquire(sensor_read_guard_t *guard)
{
    if (guard == NULL) {
        return;
    }

    guard->mutex_acquired = false;
    // Ensure we serialize all manual sensor read operations
    if (s_sensor_guard_mutex == NULL) {
        s_sensor_guard_mutex = xSemaphoreCreateMutex();
        if (s_sensor_guard_mutex == NULL) {
            ESP_LOGE(TAG, "Failed to create sensor guard mutex");
        }
    }

    if (s_sensor_guard_mutex != NULL) {
        if (xSemaphoreTake(s_sensor_guard_mutex, portMAX_DELAY) == pdTRUE) {
            guard->mutex_acquired = true;
        } else {
            ESP_LOGW(TAG, "Failed to acquire sensor guard mutex");
            guard->mutex_acquired = false;
        }
    }

    guard->should_resume = false;

    bool already_paused = sensor_manager_is_reading_paused();
    if (!already_paused) {
        if (sensor_manager_pause_reading() == ESP_OK) {
            guard->should_resume = true;
        } else {
            ESP_LOGW(TAG, "Failed to pause sensor reading task before action");
        }
    }

    const TickType_t timeout_ticks = pdMS_TO_TICKS(EZO_LONG_WAIT_MS + 2000);
    TickType_t start = xTaskGetTickCount();
    while (sensor_manager_is_reading_in_progress()) {
        if ((xTaskGetTickCount() - start) > timeout_ticks) {
            ESP_LOGW(TAG, "Timeout waiting for sensor reading task to idle");
            break;
        }
        vTaskDelay(pdMS_TO_TICKS(50));
    }
}

static void sensor_read_guard_release(sensor_read_guard_t *guard)
{
    if (guard == NULL) {
        return;
    }

    if (guard->should_resume) {
        sensor_manager_resume_reading();
    }
    guard->should_resume = false;

    if (guard->mutex_acquired && s_sensor_guard_mutex != NULL) {
        xSemaphoreGive(s_sensor_guard_mutex);
        guard->mutex_acquired = false;
    }
}

typedef struct {
    httpd_handle_t server;
    int fd;
    char *payload;
    size_t len;
} ws_async_send_arg_t;

static void ws_send_work_cb(void *arg)
{
    ws_async_send_arg_t *resp = (ws_async_send_arg_t *)arg;
    if (resp == NULL) {
        return;
    }

    if (resp->server != NULL) {
        httpd_ws_frame_t frame = {
            .final = true,
            .fragmented = false,
            .type = HTTPD_WS_TYPE_TEXT,
            .payload = (uint8_t *)resp->payload,
            .len = resp->len
        };

        esp_err_t ret = httpd_ws_send_frame_async(resp->server, resp->fd, &frame);
        if (ret != ESP_OK) {
            ESP_LOGW(TAG, "Failed to send WS frame to fd %d: %s", resp->fd, esp_err_to_name(ret));
            sensor_ws_remove_client(resp->fd);
        }
    }

    if (resp->payload != NULL) {
        free(resp->payload);
    }
    free(resp);
}

static void sensor_ws_ensure_mutex(void)
{
    if (s_ws_clients_mutex == NULL) {
        s_ws_clients_mutex = xSemaphoreCreateMutex();
        if (s_ws_clients_mutex == NULL) {
            ESP_LOGE(TAG, "Failed to create WS client mutex");
        }
    }
}

static void sensor_ws_add_client(int fd)
{
    sensor_ws_ensure_mutex();
    if (s_ws_clients_mutex == NULL) {
        return;
    }
    if (xSemaphoreTake(s_ws_clients_mutex, pdMS_TO_TICKS(50)) == pdTRUE) {
        bool added = false;
        for (int i = 0; i < SENSOR_WS_MAX_CLIENTS; i++) {
            if (!s_ws_clients[i].active) {
                s_ws_clients[i].active = true;
                s_ws_clients[i].fd = fd;
                ESP_LOGI(TAG, "WS client added (fd=%d, slot=%d)", fd, i);
                added = true;
                break;
            }
        }
        xSemaphoreGive(s_ws_clients_mutex);

        if (!added) {
            ESP_LOGW(TAG, "WS client limit reached, closing fd %d", fd);
            httpd_sess_trigger_close(s_server, fd);
        }
    }
}

static void sensor_ws_remove_client(int fd)
{
    if (s_ws_clients_mutex == NULL) {
        return;
    }
    if (xSemaphoreTake(s_ws_clients_mutex, pdMS_TO_TICKS(50)) == pdTRUE) {
        for (int i = 0; i < SENSOR_WS_MAX_CLIENTS; i++) {
            if (s_ws_clients[i].active && s_ws_clients[i].fd == fd) {
                ESP_LOGI(TAG, "WS client removed (fd=%d)", fd);
                s_ws_clients[i].active = false;
                s_ws_clients[i].fd = -1;
                break;
            }
        }
        bool any_active = false;
        for (int i = 0; i < SENSOR_WS_MAX_CLIENTS; i++) {
            if (s_ws_clients[i].active) {
                any_active = true;
                break;
            }
        }
        xSemaphoreGive(s_ws_clients_mutex);

        if (!any_active && s_focus_stream_active) {
            ESP_LOGI(TAG, "No WS clients connected, stopping focus stream");
            focus_stream_stop();
        }
    }
}

static bool sensor_ws_has_clients(void)
{
    if (s_ws_clients_mutex == NULL) {
        return false;
    }
    bool result = false;
    if (xSemaphoreTake(s_ws_clients_mutex, pdMS_TO_TICKS(50)) == pdTRUE) {
        for (int i = 0; i < SENSOR_WS_MAX_CLIENTS; i++) {
            if (s_ws_clients[i].active) {
                result = true;
                break;
            }
        }
        xSemaphoreGive(s_ws_clients_mutex);
    }
    return result;
}

static void sensor_ws_send_json_to_client(int fd, const char *json, size_t len)
{
    if (s_server == NULL || json == NULL || len == 0) {
        return;
    }

    ws_async_send_arg_t *arg = calloc(1, sizeof(ws_async_send_arg_t));
    if (arg == NULL) {
        return;
    }
    arg->payload = malloc(len);
    if (arg->payload == NULL) {
        free(arg);
        return;
    }
    memcpy(arg->payload, json, len);
    arg->len = len;
    arg->fd = fd;
    arg->server = s_server;

    if (httpd_queue_work(s_server, ws_send_work_cb, arg) != ESP_OK) {
        ESP_LOGW(TAG, "Failed to queue WS send work");
        free(arg->payload);
        free(arg);
    }
}

static void sensor_ws_broadcast_json(const char *json, size_t len)
{
    if (json == NULL || len == 0 || s_server == NULL) {
        return;
    }
    if (!sensor_ws_has_clients()) {
        return;
    }

    if (s_ws_clients_mutex == NULL) {
        return;
    }

    int targets[SENSOR_WS_MAX_CLIENTS];
    size_t target_count = 0;
    if (xSemaphoreTake(s_ws_clients_mutex, pdMS_TO_TICKS(50)) == pdTRUE) {
        for (int i = 0; i < SENSOR_WS_MAX_CLIENTS; i++) {
            if (s_ws_clients[i].active && target_count < SENSOR_WS_MAX_CLIENTS) {
                targets[target_count++] = s_ws_clients[i].fd;
            }
        }
        xSemaphoreGive(s_ws_clients_mutex);
    }

    for (size_t i = 0; i < target_count; i++) {
        sensor_ws_send_json_to_client(targets[i], json, len);
    }
}

static cJSON *create_sensors_object_from_cache(const sensor_cache_t *cache)
{
    cJSON *sensors = cJSON_CreateObject();
    if (sensors == NULL || cache == NULL) {
        return sensors;
    }

    for (uint8_t i = 0; i < cache->sensor_count && i < 8; i++) {
        const cached_sensor_t *sensor = &cache->sensors[i];
        if (!sensor->valid) {
            continue;
        }

        if (sensor->value_count == 1) {
            cJSON_AddNumberToObject(sensors, sensor->sensor_type, sensor->values[0]);
        } else if (sensor->value_count > 1) {
            cJSON *sensor_obj = cJSON_CreateObject();
            if (sensor_obj == NULL) {
                continue;
            }

            if (strcmp(sensor->sensor_type, "HUM") == 0) {
                if (sensor->value_count >= 1) cJSON_AddNumberToObject(sensor_obj, "humidity", sensor->values[0]);
                if (sensor->value_count >= 2) cJSON_AddNumberToObject(sensor_obj, "air_temp", sensor->values[1]);
                if (sensor->value_count >= 3) cJSON_AddNumberToObject(sensor_obj, "dew_point", sensor->values[2]);
            } else if (strcmp(sensor->sensor_type, "EC") == 0) {
                if (sensor->value_count >= 1) cJSON_AddNumberToObject(sensor_obj, "conductivity", sensor->values[0]);
                if (sensor->value_count >= 2) cJSON_AddNumberToObject(sensor_obj, "tds", sensor->values[1]);
                if (sensor->value_count >= 3) cJSON_AddNumberToObject(sensor_obj, "salinity", sensor->values[2]);
                if (sensor->value_count >= 4) cJSON_AddNumberToObject(sensor_obj, "specific_gravity", sensor->values[3]);
            } else if (strcmp(sensor->sensor_type, "DO") == 0) {
                if (sensor->value_count >= 1) cJSON_AddNumberToObject(sensor_obj, "dissolved_oxygen", sensor->values[0]);
                if (sensor->value_count >= 2) cJSON_AddNumberToObject(sensor_obj, "saturation", sensor->values[1]);
            } else {
                for (uint8_t j = 0; j < sensor->value_count; j++) {
                    char field_name[16];
                    snprintf(field_name, sizeof(field_name), "value_%d", j);
                    cJSON_AddNumberToObject(sensor_obj, field_name, sensor->values[j]);
                }
            }

            cJSON_AddItemToObject(sensors, sensor->sensor_type, sensor_obj);
        }
    }

    return sensors;
}

static void sensor_ws_emit_status_payload(const sensor_cache_t *cache, int target_fd)
{
    if (cache == NULL) {
        return;
    }

    cJSON *root = cJSON_CreateObject();
    if (root == NULL) {
        return;
    }

    cJSON_AddStringToObject(root, "type", "status_snapshot");
    cJSON_AddNumberToObject(root, "timestamp_ms", (double)(cache->timestamp_us / 1000ULL));
    if (cache->battery_valid) {
        cJSON_AddNumberToObject(root, "battery", cache->battery_percentage);
    }
    cJSON_AddNumberToObject(root, "rssi", cache->rssi);

    cJSON *sensors = create_sensors_object_from_cache(cache);
    if (sensors != NULL) {
        cJSON_AddItemToObject(root, "sensors", sensors);
    }

    char *json = cJSON_PrintUnformatted(root);
    cJSON_Delete(root);

    if (json != NULL) {
        if (target_fd >= 0) {
            sensor_ws_send_json_to_client(target_fd, json, strlen(json));
        } else {
            sensor_ws_broadcast_json(json, strlen(json));
        }
        free(json);
    }
}

static void sensor_ws_send_status_event(const sensor_cache_t *cache)
{
    sensor_ws_emit_status_payload(cache, -1);
}

static void sensor_ws_send_snapshot_to_client(int fd)
{
    sensor_cache_t cache;
    if (sensor_manager_get_cached_data(&cache) == ESP_OK) {
        sensor_ws_emit_status_payload(&cache, fd);
    }
}

static void handle_sensor_cache_update(const sensor_cache_t *cache, void *ctx)
{
    (void)ctx;
    sensor_ws_send_status_event(cache);
}

static void sensor_ws_send_focus_status(const char *status, uint8_t address)
{
    if (status == NULL) {
        return;
    }

    cJSON *root = cJSON_CreateObject();
    if (root == NULL) {
        return;
    }

    cJSON_AddStringToObject(root, "type", "focus_status");
    cJSON_AddStringToObject(root, "status", status);
    cJSON_AddNumberToObject(root, "address", address);

    char *json = cJSON_PrintUnformatted(root);
    cJSON_Delete(root);

    if (json != NULL) {
        sensor_ws_broadcast_json(json, strlen(json));
        free(json);
    }
}

static void sensor_ws_send_focus_sample(ezo_sensor_t *sensor, const float *values, uint8_t count)
{
    if (sensor == NULL || values == NULL || count == 0) {
        return;
    }

    cJSON *sensor_json = build_sensor_json(sensor, -1, true);
    if (sensor_json == NULL) {
        return;
    }

    uint64_t timestamp_ms = esp_timer_get_time() / 1000ULL;
    cJSON_AddNumberToObject(sensor_json, "timestamp_ms", (double)timestamp_ms);
    cJSON_AddNumberToObject(sensor_json, "value_count", count);

    cJSON *raw = cJSON_CreateArray();
    if (raw != NULL) {
        for (uint8_t i = 0; i < count; i++) {
            cJSON_AddItemToArray(raw, cJSON_CreateNumber(values[i]));
        }
        cJSON_AddItemToObject(sensor_json, "raw", raw);
    }

    add_sample_readings_to_json(sensor_json, sensor->config.type, values, count);

    cJSON *root = cJSON_CreateObject();
    if (root == NULL) {
        cJSON_Delete(sensor_json);
        return;
    }

    cJSON_AddStringToObject(root, "type", "focus_sample");
    cJSON_AddItemToObject(root, "sensor", sensor_json);

    char *json = cJSON_PrintUnformatted(root);
    cJSON_Delete(root);

    if (json != NULL) {
        sensor_ws_broadcast_json(json, strlen(json));
        free(json);
    }
}

static void focus_timer_cb(void *arg)
{
    (void)arg;
    focus_stream_sample_now();
}

static void wait_for_sensor_reading_idle(void)
{
    const TickType_t timeout_ticks = pdMS_TO_TICKS(EZO_LONG_WAIT_MS + 2000);
    TickType_t start = xTaskGetTickCount();
    while (sensor_manager_is_reading_in_progress()) {
        if ((xTaskGetTickCount() - start) > timeout_ticks) {
            ESP_LOGW(TAG, "Timeout waiting for sensor reading task to idle");
            break;
        }
        vTaskDelay(pdMS_TO_TICKS(50));
    }
}

static esp_err_t focus_stream_start(uint8_t address)
{
    ezo_sensor_t *sensor = find_sensor_by_address(address);
    if (sensor == NULL) {
        return ESP_ERR_NOT_FOUND;
    }

    if (s_focus_stream_active) {
        s_focus_sensor_address = address;
        focus_stream_sample_now();
        sensor_ws_send_focus_status("started", address);
        return ESP_OK;
    }

    if (!sensor_manager_is_reading_paused()) {
        sensor_manager_pause_reading();
        s_focus_paused_readings = true;
    } else {
        s_focus_paused_readings = false;
    }

    wait_for_sensor_reading_idle();

    s_focus_sensor_address = address;
    s_focus_stream_active = true;

    if (s_focus_timer == NULL) {
        esp_timer_create_args_t args = {
            .callback = focus_timer_cb,
            .arg = NULL,
            .dispatch_method = ESP_TIMER_TASK,
            .name = "focus_stream"
        };
        if (esp_timer_create(&args, &s_focus_timer) != ESP_OK) {
            ESP_LOGE(TAG, "Failed to create focus stream timer");
            s_focus_stream_active = false;
            return ESP_FAIL;
        }
    } else {
        esp_timer_stop(s_focus_timer);
    }

    focus_stream_sample_now();

    esp_timer_start_periodic(s_focus_timer, FOCUS_SAMPLE_INTERVAL_MS * 1000ULL);
    sensor_ws_send_focus_status("started", address);
    return ESP_OK;
}

static void focus_stream_stop(void)
{
    if (s_focus_timer != NULL) {
        esp_timer_stop(s_focus_timer);
    }

    if (!s_focus_stream_active && !s_focus_paused_readings) {
        return;
    }

    uint8_t last_address = s_focus_sensor_address;
    s_focus_stream_active = false;
    s_focus_sensor_address = 0;

    if (s_focus_paused_readings) {
        sensor_manager_resume_reading();
        s_focus_paused_readings = false;
    }

    sensor_ws_send_focus_status("stopped", last_address);
}

static void focus_stream_sample_now(void)
{
    if (!s_focus_stream_active) {
        return;
    }

    ezo_sensor_t *sensor = find_sensor_by_address(s_focus_sensor_address);
    if (sensor == NULL) {
        ESP_LOGW(TAG, "Focus sensor 0x%02X not found", s_focus_sensor_address);
        focus_stream_stop();
        return;
    }

    float values[4] = {0};
    uint8_t count = 0;

    sensor_read_guard_t guard;
    sensor_read_guard_acquire(&guard);
    esp_err_t ret = ezo_sensor_read_all(sensor, values, &count);
    sensor_read_guard_release(&guard);

    if (ret == ESP_OK && count > 0) {
        sensor_ws_send_focus_sample(sensor, values, count);
    } else {
        ESP_LOGW(TAG, "Focus read failed for 0x%02X: %s", sensor->config.i2c_address, esp_err_to_name(ret));
    }
}

static void handle_ws_command(int client_fd, const char *payload, size_t len)
{
    if (payload == NULL || len == 0) {
        return;
    }

    cJSON *root = cJSON_ParseWithLength(payload, len);
    if (root == NULL) {
        ESP_LOGW(TAG, "Invalid WS payload");
        return;
    }

    cJSON *action = cJSON_GetObjectItem(root, "action");
    if (cJSON_IsString(action) && action->valuestring != NULL) {
        if (strcmp(action->valuestring, "request_snapshot") == 0) {
            sensor_ws_send_snapshot_to_client(client_fd);
        } else if (strcmp(action->valuestring, "focus_start") == 0) {
            cJSON *addr = cJSON_GetObjectItem(root, "address");
            if (cJSON_IsNumber(addr)) {
                uint8_t address = (uint8_t)addr->valueint;
                esp_err_t ret = focus_stream_start(address);
                if (ret != ESP_OK) {
                    sensor_ws_send_focus_status("error", address);
                }
            }
        } else if (strcmp(action->valuestring, "focus_stop") == 0) {
            focus_stream_stop();
        }
    }

    cJSON_Delete(root);
}

static bool parse_sensor_address_from_uri(const char *uri, const char *prefix, uint8_t *address)
{
    if (uri == NULL || prefix == NULL || address == NULL) {
        return false;
    }
    size_t prefix_len = strlen(prefix);
    if (strncmp(uri, prefix, prefix_len) != 0) {
        return false;
    }
    const char *addr_str = uri + prefix_len;
    if (*addr_str == '\0') {
        return false;
    }
    char *endptr = NULL;
    long value = strtol(addr_str, &endptr, 0);  // base 0 to allow decimal or 0xNN
    if (endptr == NULL || *endptr != '\0' || value < 0 || value > 255) {
        return false;
    }
    *address = (uint8_t)value;
    return true;
}

static ezo_sensor_t *find_sensor_by_address(uint8_t address)
{
    uint8_t ezo_count = sensor_manager_get_ezo_count();
    for (uint8_t i = 0; i < ezo_count; i++) {
        ezo_sensor_t *sensor = (ezo_sensor_t *)sensor_manager_get_ezo_sensor(i);
        if (sensor != NULL && sensor->config.i2c_address == address) {
            return sensor;
        }
    }
    return NULL;
}

static void add_capabilities_array(cJSON *parent, uint32_t flags)
{
    cJSON *caps = cJSON_CreateArray();
    if (caps == NULL) {
        return;
    }
    if (flags & EZO_CAP_CALIBRATION) cJSON_AddItemToArray(caps, cJSON_CreateString("calibration"));
    if (flags & EZO_CAP_TEMP_COMP)   cJSON_AddItemToArray(caps, cJSON_CreateString("temp_comp"));
    if (flags & EZO_CAP_MODE)        cJSON_AddItemToArray(caps, cJSON_CreateString("mode"));
    if (flags & EZO_CAP_SLEEP)       cJSON_AddItemToArray(caps, cJSON_CreateString("sleep"));
    if (flags & EZO_CAP_OFFSET)      cJSON_AddItemToArray(caps, cJSON_CreateString("offset"));
    cJSON_AddItemToObject(parent, "capabilities", caps);
}

static void append_sensor_runtime_info(cJSON *json, ezo_sensor_t *sensor)
{
    if (json == NULL || sensor == NULL) {
        return;
    }

    if (sensor->config.capability_flags & EZO_CAP_CALIBRATION) {
        if (sensor->config.calibration_status_valid && sensor->config.calibration_status[0] != '\0') {
            cJSON_AddStringToObject(json, "calibration_status", sensor->config.calibration_status);
        } else {
            cJSON_AddStringToObject(json, "calibration_status", "unknown");
        }
    }

    if ((sensor->config.capability_flags & EZO_CAP_TEMP_COMP) && strcmp(sensor->config.type, EZO_TYPE_PH) == 0) {
        if (sensor->config.temp_comp_valid) {
            cJSON_AddNumberToObject(json, "temperature_comp", sensor->config.temp_compensation);
        }
    }

    if (sensor->config.capability_flags & EZO_CAP_MODE) {
        cJSON_AddBoolToObject(json, "continuous_mode", sensor->config.continuous_mode);
    }

    if (sensor->config.capability_flags & EZO_CAP_SLEEP) {
        cJSON_AddBoolToObject(json, "sleeping", sensor->config.sleeping);
    }
}

static void add_sample_readings_to_json(cJSON *json, const char *type, const float values[], uint8_t count)
{
    if (json == NULL || type == NULL || values == NULL || count == 0) {
        return;
    }

    bool is_multi_value = false;
    if (strcmp(type, EZO_TYPE_EC) == 0 || strcmp(type, EZO_TYPE_HUM) == 0 || strcmp(type, EZO_TYPE_DO) == 0) {
        is_multi_value = true;
    }

    if (!is_multi_value && count == 1) {
        cJSON_AddNumberToObject(json, "reading", values[0]);
        return;
    }

    cJSON *reading = cJSON_CreateObject();
    if (reading == NULL) {
        return;
    }

    if (strcmp(type, EZO_TYPE_EC) == 0) {
        if (count >= 1) cJSON_AddNumberToObject(reading, "conductivity", values[0]);
        if (count >= 2) cJSON_AddNumberToObject(reading, "tds", values[1]);
        if (count >= 3) cJSON_AddNumberToObject(reading, "salinity", values[2]);
        if (count >= 4) cJSON_AddNumberToObject(reading, "specific_gravity", values[3]);
    } else if (strcmp(type, EZO_TYPE_HUM) == 0) {
        if (count >= 1) cJSON_AddNumberToObject(reading, "humidity", values[0]);
        if (count >= 2) cJSON_AddNumberToObject(reading, "air_temp", values[1]);
        if (count >= 3) cJSON_AddNumberToObject(reading, "dew_point", values[2]);
    } else if (strcmp(type, EZO_TYPE_DO) == 0) {
        if (count >= 1) cJSON_AddNumberToObject(reading, "dissolved_oxygen", values[0]);
        if (count >= 2) cJSON_AddNumberToObject(reading, "saturation", values[1]);
    } else {
        for (uint8_t i = 0; i < count; i++) {
            char key[12];
            snprintf(key, sizeof(key), "value%d", i + 1);
            cJSON_AddNumberToObject(reading, key, values[i]);
        }
    }

    cJSON_AddItemToObject(json, "reading", reading);
}

static cJSON *build_sensor_json(ezo_sensor_t *sensor, int index, bool include_runtime)
{
    if (sensor == NULL) {
        return NULL;
    }

    cJSON *obj = cJSON_CreateObject();
    if (obj == NULL) {
        return NULL;
    }

    if (index >= 0) {
        cJSON_AddNumberToObject(obj, "index", index);
    }
    cJSON_AddNumberToObject(obj, "address", sensor->config.i2c_address);
    cJSON_AddStringToObject(obj, "type", sensor->config.type);
    cJSON_AddStringToObject(obj, "name", sensor->config.name);
    cJSON_AddStringToObject(obj, "firmware", sensor->config.firmware_version);
    cJSON_AddBoolToObject(obj, "led", sensor->config.led_control);
    cJSON_AddBoolToObject(obj, "plock", sensor->config.protocol_lock);
    add_capabilities_array(obj, sensor->config.capability_flags);

    if (strcmp(sensor->config.type, EZO_TYPE_RTD) == 0) {
        cJSON_AddStringToObject(obj, "scale", (const char[]){sensor->config.rtd.temperature_scale, '\0'});
    } else if (strcmp(sensor->config.type, EZO_TYPE_PH) == 0) {
        cJSON_AddBoolToObject(obj, "extended_scale", sensor->config.ph.extended_scale);
    } else if (strcmp(sensor->config.type, EZO_TYPE_EC) == 0) {
        cJSON_AddNumberToObject(obj, "probe_type", sensor->config.ec.probe_type);
        cJSON_AddNumberToObject(obj, "tds_factor", sensor->config.ec.tds_conversion_factor);
    }

    if (include_runtime) {
        append_sensor_runtime_info(obj, sensor);
    }

    return obj;
}

static cJSON *parse_request_json_body(httpd_req_t *req, char **raw_buffer)
{
    if (req->content_len <= 0) {
        return NULL;
    }

    char *buffer = malloc(req->content_len + 1);
    if (buffer == NULL) {
        return NULL;
    }

    int total = 0;
    while (total < req->content_len) {
        int received = httpd_req_recv(req, buffer + total, req->content_len - total);
        if (received <= 0) {
            free(buffer);
            return NULL;
        }
        total += received;
    }
    buffer[total] = '\0';

    cJSON *json = cJSON_Parse(buffer);
    if (json == NULL) {
        free(buffer);
        if (raw_buffer != NULL) {
            *raw_buffer = NULL;
        }
        return NULL;
    }

    if (raw_buffer != NULL) {
        *raw_buffer = buffer;
    } else {
        free(buffer);
    }
    return json;
}

/**
 * @brief Favicon handler - return 204 No Content to avoid 404 errors
 */
static esp_err_t favicon_handler(httpd_req_t *req)
{
    httpd_resp_set_status(req, "204 No Content");
    httpd_resp_send(req, NULL, 0);
    return ESP_OK;
}

/**
 * @brief Root handler - serve dashboard from on-device filesystem or embedded fallback
 */
static esp_err_t root_handler(httpd_req_t *req)
{
    httpd_resp_set_type(req, "text/html");
    httpd_resp_set_hdr(req, "Connection", "keep-alive");
    httpd_resp_set_hdr(req, "Cache-Control", "no-cache, no-store, must-revalidate");
    httpd_resp_set_hdr(req, "Pragma", "no-cache");
    httpd_resp_set_hdr(req, "Expires", "0");
    
    // Try to load from the writable filesystem first
    char *content = NULL;
    size_t size = 0;
    if (web_editor_load_file("index.html", &content, &size) == ESP_OK) {
        ESP_LOGI(TAG, "Serving index.html from FATFS (%d bytes)", size);
        httpd_resp_send(req, content, size);
        free(content);
        return ESP_OK;
    }
    
    // Fallback to embedded HTML
    ESP_LOGI(TAG, "Serving index.html from embedded image (filesystem read failed)");
    const size_t html_size = index_html_end - index_html_start;
    httpd_resp_send(req, (const char *)index_html_start, html_size);
    return ESP_OK;
}

/**
 * @brief API status endpoint - return device status as JSON
 */
static esp_err_t api_status_handler(httpd_req_t *req)
{
    cJSON *root = cJSON_CreateObject();
    
    // Device ID
    char device_id[32];
    cloud_prov_get_device_id(device_id, sizeof(device_id));
    cJSON_AddStringToObject(root, "device_id", device_id);
    
    // WiFi SSID
    char ssid[33];
    char password[64];
    if (wifi_manager_get_stored_credentials(ssid, password) == ESP_OK) {
        cJSON_AddStringToObject(root, "wifi_ssid", ssid);
        memset(password, 0, sizeof(password)); // Clear password
    } else {
        cJSON_AddStringToObject(root, "wifi_ssid", "Not configured");
    }
    
    // IP Address
    if (wifi_manager_is_connected()) {
        // TODO: Get actual IP address from WiFi manager
        cJSON_AddStringToObject(root, "ip_address", "Connected");
    } else {
        cJSON_AddStringToObject(root, "ip_address", "Disconnected");
    }
    
    // WiFi RSSI
    if (wifi_manager_is_connected()) {
        wifi_ap_record_t ap_info;
        if (esp_wifi_sta_get_ap_info(&ap_info) == ESP_OK) {
            cJSON_AddNumberToObject(root, "rssi", ap_info.rssi);
        }
    }
    
    // Uptime
    cJSON_AddNumberToObject(root, "uptime", esp_timer_get_time() / 1000000);
    
    // Current time
    char time_str[64];
    if (time_sync_get_time_string(time_str, sizeof(time_str), NULL) == ESP_OK) {
        cJSON_AddStringToObject(root, "current_time", time_str);
    } else {
        cJSON_AddStringToObject(root, "current_time", "Not synced");
    }
    
    // Free heap
    cJSON_AddNumberToObject(root, "free_heap", esp_get_free_heap_size());
    
    // CPU usage (simplified estimate based on idle task)
    // TODO: Implement more accurate CPU monitoring
    cJSON_AddNumberToObject(root, "cpu_usage", 25);
    
    // Get cached sensor data from sensor_manager (non-blocking, no I2C operations)
    sensor_cache_t cache;
    if (sensor_manager_get_cached_data(&cache) == ESP_OK) {
        if (cache.battery_valid) {
            cJSON_AddNumberToObject(root, "battery", cache.battery_percentage);
        }

        cJSON *sensors = create_sensors_object_from_cache(&cache);
        if (sensors != NULL) {
            cJSON_AddItemToObject(root, "sensors", sensors);
        }
    }
    
    // Send JSON response
    const char *json_str = cJSON_PrintUnformatted(root);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, json_str, HTTPD_RESP_USE_STRLEN);
    
    free((void *)json_str);
    cJSON_Delete(root);
    return ESP_OK;
}

static esp_err_t sensor_ws_handler(httpd_req_t *req)
{
    int client_fd = httpd_req_to_sockfd(req);
    if (req->method == HTTP_GET) {
        sensor_ws_add_client(client_fd);
        sensor_ws_send_snapshot_to_client(client_fd);
        return ESP_OK;
    }

    httpd_ws_frame_t frame = {
        .type = HTTPD_WS_TYPE_TEXT,
        .final = true,
        .fragmented = false,
        .payload = NULL,
        .len = 0
    };

    esp_err_t ret = httpd_ws_recv_frame(req, &frame, 0);
    if (ret != ESP_OK) {
        return ret;
    }

    if (frame.len > 0) {
        frame.payload = malloc(frame.len + 1);
        if (frame.payload == NULL) {
            return ESP_ERR_NO_MEM;
        }
        ret = httpd_ws_recv_frame(req, &frame, frame.len);
        if (ret != ESP_OK) {
            free(frame.payload);
            return ret;
        }
        frame.payload[frame.len] = '\0';
    }

    if (frame.type == HTTPD_WS_TYPE_TEXT && frame.payload != NULL) {
        handle_ws_command(client_fd, (const char *)frame.payload, frame.len);
    } else if (frame.type == HTTPD_WS_TYPE_CLOSE) {
        sensor_ws_remove_client(client_fd);
    } else if (frame.type == HTTPD_WS_TYPE_PING) {
        frame.type = HTTPD_WS_TYPE_PONG;
        httpd_ws_send_frame(req, &frame);
    }

    if (frame.payload != NULL) {
        free(frame.payload);
    }

    return ESP_OK;
}

/**
 * @brief API clear WiFi endpoint
 */
static esp_err_t api_clear_wifi_handler(httpd_req_t *req)
{
    ESP_LOGW(TAG, "WiFi clear requested via dashboard");
    
    // Clear WiFi credentials
    wifi_manager_clear_credentials();
    
    // Send response
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, "{\"status\":\"success\"}", HTTPD_RESP_USE_STRLEN);
    
    // Restart device after a delay
    vTaskDelay(pdMS_TO_TICKS(1000));
    esp_restart();
    
    return ESP_OK;
}

/**
 * @brief API reboot endpoint
 */
static esp_err_t api_reboot_handler(httpd_req_t *req)
{
    ESP_LOGW(TAG, "Reboot requested via dashboard");
    
    // Send response
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, "{\"status\":\"rebooting\"}", HTTPD_RESP_USE_STRLEN);
    
    // Restart device after a delay
    vTaskDelay(pdMS_TO_TICKS(1000));
    esp_restart();
    
    return ESP_OK;
}

/**
 * @brief API test MQTT endpoint
 */
static esp_err_t api_test_mqtt_handler(httpd_req_t *req)
{
    ESP_LOGI(TAG, "MQTT connection test requested");
    
    // Check if MQTT is connected
    // Note: mqtt_telemetry module doesn't expose connection status yet
    // For now, just return success
    
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, "{\"status\":\"tested\",\"connected\":true}", HTTPD_RESP_USE_STRLEN);
    
    return ESP_OK;
}

/**
 * @brief API settings endpoint
 */
static esp_err_t api_settings_handler(httpd_req_t *req)
{
    // Handle GET request - return current settings
    if (req->method == HTTP_GET) {
        cJSON *root = cJSON_CreateObject();
        
        // Get current MQTT telemetry interval
        uint32_t mqtt_interval = mqtt_get_telemetry_interval();
        cJSON_AddNumberToObject(root, "mqtt_interval", mqtt_interval);
        
        // Get sensor reading interval
        uint32_t sensor_interval = sensor_manager_get_reading_interval();
        cJSON_AddNumberToObject(root, "sensor_interval", sensor_interval);
        
        char *json_str = cJSON_PrintUnformatted(root);
        cJSON_Delete(root);
        
        httpd_resp_set_type(req, "application/json");
        httpd_resp_sendstr(req, json_str);
        free(json_str);
        
        return ESP_OK;
    }
    
    // Handle POST request - update settings
    char content[200];
    int ret = httpd_req_recv(req, content, sizeof(content) - 1);
    if (ret <= 0) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid request");
        return ESP_FAIL;
    }
    content[ret] = '\0';
    
    // Parse JSON
    cJSON *root = cJSON_Parse(content);
    if (root == NULL) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid JSON");
        return ESP_FAIL;
    }
    
    // Update MQTT telemetry interval if present
    cJSON *mqtt_interval = cJSON_GetObjectItem(root, "mqtt_interval");
    if (mqtt_interval != NULL && cJSON_IsNumber(mqtt_interval)) {
        int interval_val = mqtt_interval->valueint;
        if (interval_val < 0) {
            cJSON_Delete(root);
            httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Interval must be >= 0");
            return ESP_FAIL;
        }
        
        ESP_LOGI(TAG, "Setting MQTT telemetry interval to %d seconds (0=on-read only)", interval_val);
        esp_err_t err = mqtt_set_telemetry_interval(interval_val);
        if (err != ESP_OK) {
            ESP_LOGE(TAG, "Failed to set MQTT interval: %s", esp_err_to_name(err));
        }
    }
    
    // Update sensor reading interval if present
    cJSON *sensor_interval = cJSON_GetObjectItem(root, "sensor_interval");
    if (sensor_interval != NULL && cJSON_IsNumber(sensor_interval)) {
        int interval_val = sensor_interval->valueint;
        if (interval_val < 1) {
            cJSON_Delete(root);
            httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Sensor interval must be >= 1");
            return ESP_FAIL;
        }
        
        ESP_LOGI(TAG, "Setting sensor reading interval to %d seconds", interval_val);
        sensor_manager_set_reading_interval(interval_val);
    }
    
    cJSON_Delete(root);
    
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, "{\"status\":\"saved\"}", HTTPD_RESP_USE_STRLEN);
    
    return ESP_OK;
}

/**
 * @brief POST /api/settings/reset - Reset settings to defaults
 */
static esp_err_t api_settings_reset_handler(httpd_req_t *req)
{
    const uint32_t DEFAULT_MQTT_INTERVAL = 10;
    const uint32_t DEFAULT_SENSOR_INTERVAL = 10;
    
    ESP_LOGI(TAG, "Resetting settings to defaults");
    
    // Reset MQTT interval
    mqtt_set_telemetry_interval(DEFAULT_MQTT_INTERVAL);
    
    // Reset sensor interval
    sensor_manager_set_reading_interval(DEFAULT_SENSOR_INTERVAL);
    
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"status\":\"reset\",\"mqtt_interval\":10,\"sensor_interval\":10}");
    
    return ESP_OK;
}

/**
 * @brief POST /api/sensors/pause - Pause sensor reading task
 */
static esp_err_t api_sensors_pause_handler(httpd_req_t *req)
{
    sensor_manager_pause_reading();
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"status\":\"paused\"}");
    return ESP_OK;
}

/**
 * @brief POST /api/sensors/resume - Resume sensor reading task
 */
static esp_err_t api_sensors_resume_handler(httpd_req_t *req)
{
    sensor_manager_resume_reading();
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"status\":\"resumed\"}");
    return ESP_OK;
}

/**
 * @brief GET /api/sensors - Get list of all sensors with their configurations
 */
static esp_err_t api_sensors_list_handler(httpd_req_t *req)
{
    esp_err_t refresh_ret = sensor_manager_refresh_settings();
    if (refresh_ret != ESP_OK) {
        ESP_LOGW(TAG, "Sensor settings refresh failed: %s", esp_err_to_name(refresh_ret));
    }

    cJSON *root = cJSON_CreateObject();
    cJSON *sensors = cJSON_CreateArray();
    
    // Add battery monitor if available
    if (sensor_manager_has_battery_monitor()) {
        cJSON *battery = cJSON_CreateObject();
        cJSON_AddStringToObject(battery, "type", "MAX17048");
        cJSON_AddNumberToObject(battery, "address", 0x36);
        cJSON_AddStringToObject(battery, "name", "Battery Monitor");
        cJSON_AddStringToObject(battery, "description", "Li+ Battery Fuel Gauge");
        cJSON_AddItemToArray(sensors, battery);
    }
    
    // Add EZO sensors
    uint8_t ezo_count = sensor_manager_get_ezo_count();
    for (uint8_t i = 0; i < ezo_count; i++) {
        ezo_sensor_t *sensor = (ezo_sensor_t*)sensor_manager_get_ezo_sensor(i);
        if (sensor != NULL) {
            cJSON *ezo = build_sensor_json(sensor, i, true);
            if (ezo != NULL) {
                cJSON_AddItemToArray(sensors, ezo);
            }
        }
    }
    
    cJSON_AddItemToObject(root, "sensors", sensors);
    cJSON_AddNumberToObject(root, "count", cJSON_GetArraySize(sensors));
    
    const char *response = cJSON_PrintUnformatted(root);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, response);
    
    free((void*)response);
    cJSON_Delete(root);
    
    return ESP_OK;
}

/**
 * @brief POST /api/sensors/rescan - Rescan I2C bus for sensors
 */
static esp_err_t api_sensors_rescan_handler(httpd_req_t *req)
{
    ESP_LOGI(TAG, "Rescanning I2C bus for sensors");
    
    esp_err_t ret = sensor_manager_rescan();
    
    cJSON *root = cJSON_CreateObject();
    cJSON_AddStringToObject(root, "status", ret == ESP_OK ? "success" : "error");
    cJSON_AddNumberToObject(root, "battery", sensor_manager_has_battery_monitor() ? 1 : 0);
    cJSON_AddNumberToObject(root, "ezo_count", sensor_manager_get_ezo_count());
    
    const char *response = cJSON_PrintUnformatted(root);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, response);
    
    free((void*)response);
    cJSON_Delete(root);
    
    return ESP_OK;
}

static esp_err_t send_sensor_success_response(httpd_req_t *req, ezo_sensor_t *sensor)
{
    if (sensor != NULL) {
        esp_err_t refresh = ezo_sensor_refresh_settings(sensor);
        if (refresh != ESP_OK) {
            ESP_LOGW(TAG, "Failed to refresh sensor settings before response: %s", esp_err_to_name(refresh));
        }
    }

    cJSON *root = cJSON_CreateObject();
    if (root == NULL) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Out of memory");
        return ESP_FAIL;
    }
    cJSON_AddStringToObject(root, "status", "success");
    cJSON *sensor_json = build_sensor_json(sensor, -1, true);
    if (sensor_json != NULL) {
        cJSON_AddItemToObject(root, "sensor", sensor_json);
    }

    const char *response = cJSON_PrintUnformatted(root);
    if (response == NULL) {
        cJSON_Delete(root);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to serialize JSON");
        return ESP_FAIL;
    }

    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, response);
    free((void*)response);
    cJSON_Delete(root);
    return ESP_OK;
}

/**
 * @brief POST /api/sensors/config - Update sensor configuration
 * Body: {"address": 99, "led": 1, "name": "MySensor", "scale": "F", etc}
 */
static esp_err_t api_sensors_config_handler(httpd_req_t *req)
{
    char content[512];
    int ret = httpd_req_recv(req, content, sizeof(content) - 1);
    if (ret <= 0) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Empty request");
        return ESP_FAIL;
    }
    content[ret] = '\0';
    
    cJSON *root = cJSON_Parse(content);
    if (root == NULL) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid JSON");
        return ESP_FAIL;
    }
    
    cJSON *address_json = cJSON_GetObjectItem(root, "address");
    if (address_json == NULL || !cJSON_IsNumber(address_json)) {
        cJSON_Delete(root);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Missing address");
        return ESP_FAIL;
    }
    
    uint8_t address = (uint8_t)address_json->valueint;
    
    // Find sensor by address
    ezo_sensor_t *sensor = NULL;
    uint8_t ezo_count = sensor_manager_get_ezo_count();
    for (uint8_t i = 0; i < ezo_count; i++) {
        ezo_sensor_t *s = (ezo_sensor_t*)sensor_manager_get_ezo_sensor(i);
        if (s != NULL && s->config.i2c_address == address) {
            sensor = s;
            break;
        }
    }
    
    if (sensor == NULL) {
        cJSON_Delete(root);
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "Sensor not found");
        return ESP_FAIL;
    }
    
    // Update LED
    cJSON *led = cJSON_GetObjectItem(root, "led");
    if (led != NULL && cJSON_IsBool(led)) {
        ezo_sensor_set_led(sensor, cJSON_IsTrue(led));
    }
    
    // Update name with validation
    cJSON *name = cJSON_GetObjectItem(root, "name");
    if (name != NULL && cJSON_IsString(name)) {
        const char *name_str = name->valuestring;
        size_t name_len = strlen(name_str);
        
        // Validate name: 1-16 characters, alphanumeric and underscore only
        if (name_len == 0 || name_len > 16) {
            cJSON_Delete(root);
            httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Name must be 1-16 characters");
            return ESP_FAIL;
        }
        
        // Check for valid characters (alphanumeric and underscore only)
        bool valid = true;
        for (size_t i = 0; i < name_len; i++) {
            char c = name_str[i];
            if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || 
                  (c >= '0' && c <= '9') || c == '_')) {
                valid = false;
                break;
            }
        }
        
        if (!valid) {
            cJSON_Delete(root);
            httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Name must contain only letters, numbers, and underscores");
            return ESP_FAIL;
        }
        
        esp_err_t name_ret = ezo_sensor_set_name(sensor, name_str);
        if (name_ret != ESP_OK) {
            ESP_LOGW(TAG, "Failed to set sensor name: %s", esp_err_to_name(name_ret));
        }
    }
    
    // Update protocol lock
    cJSON *plock = cJSON_GetObjectItem(root, "plock");
    if (plock != NULL && cJSON_IsBool(plock)) {
        ezo_sensor_set_plock(sensor, cJSON_IsTrue(plock));
    }
    
    // Type-specific updates
    if (strcmp(sensor->config.type, "RTD") == 0) {
        cJSON *scale = cJSON_GetObjectItem(root, "scale");
        if (scale != NULL && cJSON_IsString(scale) && strlen(scale->valuestring) > 0) {
            ezo_rtd_set_scale(sensor, scale->valuestring[0]);
        }
    } else if (strcmp(sensor->config.type, "pH") == 0) {
        cJSON *ext_scale = cJSON_GetObjectItem(root, "extended_scale");
        if (ext_scale != NULL && cJSON_IsBool(ext_scale)) {
            ezo_ph_set_extended_scale(sensor, cJSON_IsTrue(ext_scale));
        }
    } else if (strcmp(sensor->config.type, "EC") == 0) {
        cJSON *probe = cJSON_GetObjectItem(root, "probe_type");
        if (probe != NULL && cJSON_IsNumber(probe)) {
            ezo_ec_set_probe_type(sensor, (float)probe->valuedouble);
        }
        
        cJSON *tds = cJSON_GetObjectItem(root, "tds_factor");
        if (tds != NULL && cJSON_IsNumber(tds)) {
            ezo_ec_set_tds_factor(sensor, (float)tds->valuedouble);
        }
    }
    
    cJSON_Delete(root);
    
    // Refresh sensor settings after update
    esp_err_t refresh_ret = ezo_sensor_refresh_settings(sensor);
    if (refresh_ret != ESP_OK) {
        ESP_LOGW(TAG, "Failed to refresh sensor settings: %s", esp_err_to_name(refresh_ret));
    }
    
    return send_sensor_success_response(req, sensor);
}

static esp_err_t api_sensor_calibrate_handler(httpd_req_t *req)
{
    uint8_t address;
    if (!parse_sensor_address_from_uri(req->uri, SENSOR_CALIBRATE_URI, &address)) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid sensor address");
        return ESP_FAIL;
    }

    ezo_sensor_t *sensor = find_sensor_by_address(address);
    if (sensor == NULL) {
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "Sensor not found");
        return ESP_FAIL;
    }

    char *raw = NULL;
    cJSON *payload = parse_request_json_body(req, &raw);
    if (payload == NULL) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid JSON");
        return ESP_FAIL;
    }

    esp_err_t ret = ESP_ERR_NOT_SUPPORTED;
    sensor_read_guard_t guard;
    bool guard_active = false;

    if (strcmp(sensor->config.type, EZO_TYPE_PH) == 0) {
        cJSON *point = cJSON_GetObjectItem(payload, "point");
        if (point == NULL || !cJSON_IsString(point)) {
            cJSON_Delete(payload);
            free(raw);
            httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Missing calibration point");
            return ESP_FAIL;
        }
        const char *point_str = point->valuestring;
        float default_value = 0.0f;
        if (strcmp(point_str, "mid") == 0) default_value = 7.00f;
        else if (strcmp(point_str, "low") == 0) default_value = 4.00f;
        else if (strcmp(point_str, "high") == 0) default_value = 10.00f;

        cJSON *value = cJSON_GetObjectItem(payload, "value");
        float cal_value = default_value;
        if (value != NULL && cJSON_IsNumber(value)) {
            cal_value = (float)value->valuedouble;
        }
        sensor_read_guard_acquire(&guard);
        guard_active = true;
        ret = ezo_ph_calibrate(sensor, point_str, cal_value);
    } else if (strcmp(sensor->config.type, EZO_TYPE_ORP) == 0) {
        bool clear = false;
        cJSON *point = cJSON_GetObjectItem(payload, "point");
        if (point != NULL && cJSON_IsString(point) && strcmp(point->valuestring, "clear") == 0) {
            clear = true;
        }
        cJSON *clear_flag = cJSON_GetObjectItem(payload, "clear");
        if (clear_flag != NULL && cJSON_IsBool(clear_flag)) {
            clear = cJSON_IsTrue(clear_flag);
        }

        sensor_read_guard_acquire(&guard);
        guard_active = true;

        if (clear) {
            ret = ezo_orp_calibrate(sensor, -1000.0f);
        } else {
            cJSON *value = cJSON_GetObjectItem(payload, "value");
            if (value == NULL || !cJSON_IsNumber(value)) {
                cJSON_Delete(payload);
                free(raw);
                sensor_read_guard_release(&guard);
                httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Missing calibration value");
                return ESP_FAIL;
            }
            ret = ezo_orp_calibrate(sensor, (float)value->valuedouble);
        }
    } else if (strcmp(sensor->config.type, EZO_TYPE_RTD) == 0) {
        bool clear = false;
        cJSON *point = cJSON_GetObjectItem(payload, "point");
        if (point != NULL && cJSON_IsString(point) && strcmp(point->valuestring, "clear") == 0) {
            clear = true;
        }

        float reference_temp = 0.0f;
        if (!clear) {
            cJSON *temperature = cJSON_GetObjectItem(payload, "temperature");
            if (temperature == NULL || !cJSON_IsNumber(temperature)) {
                cJSON_Delete(payload);
                free(raw);
                httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Missing temperature value");
                return ESP_FAIL;
            }
            reference_temp = (float)temperature->valuedouble;
        }

        sensor_read_guard_acquire(&guard);
        guard_active = true;
        ret = ezo_rtd_calibrate(sensor, clear ? -1000.0f : reference_temp);
    } else if (strcmp(sensor->config.type, EZO_TYPE_EC) == 0) {
        cJSON *point = cJSON_GetObjectItem(payload, "point");
        if (point == NULL || !cJSON_IsString(point)) {
            cJSON_Delete(payload);
            free(raw);
            httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Missing calibration point");
            return ESP_FAIL;
        }

        const char *point_str = point->valuestring;
        bool point_needs_value = (strcmp(point_str, "low") == 0) || (strcmp(point_str, "high") == 0);
        uint32_t cal_value = 0;
        if (point_needs_value) {
            cJSON *value = cJSON_GetObjectItem(payload, "value");
            if (value == NULL || !cJSON_IsNumber(value) || value->valuedouble <= 0) {
                cJSON_Delete(payload);
                free(raw);
                httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid calibration value");
                return ESP_FAIL;
            }
            cal_value = (uint32_t)(value->valuedouble + 0.5);
        }

        sensor_read_guard_acquire(&guard);
        guard_active = true;
        ret = ezo_ec_calibrate(sensor, point_str, cal_value);
    } else if (strcmp(sensor->config.type, EZO_TYPE_DO) == 0) {
        cJSON *point = cJSON_GetObjectItem(payload, "point");
        if (point == NULL || !cJSON_IsString(point)) {
            cJSON_Delete(payload);
            free(raw);
            httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Missing calibration point");
            return ESP_FAIL;
        }

        sensor_read_guard_acquire(&guard);
        guard_active = true;
        ret = ezo_do_calibrate(sensor, point->valuestring);
    }

    cJSON_Delete(payload);
    free(raw);

    if (ret != ESP_OK) {
        if (guard_active) {
            sensor_read_guard_release(&guard);
        }
        if (ret == ESP_ERR_NOT_SUPPORTED) {
            httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Calibration not supported for this sensor");
        } else {
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Calibration failed");
        }
        return ESP_FAIL;
    }

    esp_err_t resp = send_sensor_success_response(req, sensor);
    if (guard_active) {
        sensor_read_guard_release(&guard);
    }
    return resp;
}

static esp_err_t api_sensor_compensation_handler(httpd_req_t *req)
{
    uint8_t address;
    if (!parse_sensor_address_from_uri(req->uri, SENSOR_COMP_URI, &address)) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid sensor address");
        return ESP_FAIL;
    }

    ezo_sensor_t *sensor = find_sensor_by_address(address);
    if (sensor == NULL) {
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "Sensor not found");
        return ESP_FAIL;
    }

    char *raw = NULL;
    cJSON *payload = parse_request_json_body(req, &raw);
    if (payload == NULL) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid JSON");
        return ESP_FAIL;
    }

    if (strcmp(sensor->config.type, EZO_TYPE_PH) != 0) {
        cJSON_Delete(payload);
        free(raw);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Temperature compensation not supported");
        return ESP_FAIL;
    }

    cJSON *temp = cJSON_GetObjectItem(payload, "temp_c");
    if (temp == NULL || !cJSON_IsNumber(temp)) {
        cJSON_Delete(payload);
        free(raw);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Missing temp_c value");
        return ESP_FAIL;
    }
    float target = (float)temp->valuedouble;
    cJSON_Delete(payload);
    free(raw);

    sensor_read_guard_t guard;
    sensor_read_guard_acquire(&guard);

    esp_err_t ret = ezo_ph_set_temperature_comp(sensor, target);
    if (ret != ESP_OK) {
        sensor_read_guard_release(&guard);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to set temperature compensation");
        return ESP_FAIL;
    }

    esp_err_t resp = send_sensor_success_response(req, sensor);
    sensor_read_guard_release(&guard);
    return resp;
}

static esp_err_t api_sensor_mode_handler(httpd_req_t *req)
{
    uint8_t address;
    if (!parse_sensor_address_from_uri(req->uri, SENSOR_MODE_URI, &address)) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid sensor address");
        return ESP_FAIL;
    }

    ezo_sensor_t *sensor = find_sensor_by_address(address);
    if (sensor == NULL) {
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "Sensor not found");
        return ESP_FAIL;
    }

    if (!(sensor->config.capability_flags & EZO_CAP_MODE)) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Sensor does not support continuous mode");
        return ESP_FAIL;
    }

    char *raw = NULL;
    cJSON *payload = parse_request_json_body(req, &raw);
    if (payload == NULL) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid JSON");
        return ESP_FAIL;
    }

    cJSON *continuous = cJSON_GetObjectItem(payload, "continuous");
    if (continuous == NULL || !cJSON_IsBool(continuous)) {
        cJSON_Delete(payload);
        free(raw);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Missing continuous flag");
        return ESP_FAIL;
    }

    bool enable = cJSON_IsTrue(continuous);
    cJSON_Delete(payload);
    free(raw);

    sensor_read_guard_t guard;
    sensor_read_guard_acquire(&guard);

    esp_err_t ret = ezo_sensor_set_continuous_mode(sensor, enable);
    if (ret != ESP_OK) {
        sensor_read_guard_release(&guard);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to update mode");
        return ESP_FAIL;
    }

    esp_err_t resp = send_sensor_success_response(req, sensor);
    sensor_read_guard_release(&guard);
    return resp;
}

static esp_err_t api_sensor_power_handler(httpd_req_t *req)
{
    uint8_t address;
    if (!parse_sensor_address_from_uri(req->uri, SENSOR_POWER_URI, &address)) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid sensor address");
        return ESP_FAIL;
    }

    ezo_sensor_t *sensor = find_sensor_by_address(address);
    if (sensor == NULL) {
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "Sensor not found");
        return ESP_FAIL;
    }

    if (!(sensor->config.capability_flags & EZO_CAP_SLEEP)) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Sensor does not support sleep");
        return ESP_FAIL;
    }

    char *raw = NULL;
    cJSON *payload = parse_request_json_body(req, &raw);
    if (payload == NULL) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid JSON");
        return ESP_FAIL;
    }

    cJSON *sleep_flag = cJSON_GetObjectItem(payload, "sleep");
    if (sleep_flag == NULL || !cJSON_IsBool(sleep_flag)) {
        cJSON_Delete(payload);
        free(raw);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Missing sleep flag");
        return ESP_FAIL;
    }

    bool sleep = cJSON_IsTrue(sleep_flag);
    cJSON_Delete(payload);
    free(raw);

    sensor_read_guard_t guard;
    sensor_read_guard_acquire(&guard);

    esp_err_t ret = sleep ? ezo_sensor_sleep(sensor) : ezo_sensor_wake(sensor);
    if (ret != ESP_OK) {
        sensor_read_guard_release(&guard);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to change power state");
        return ESP_FAIL;
    }

    esp_err_t resp = send_sensor_success_response(req, sensor);
    sensor_read_guard_release(&guard);
    return resp;
}

static esp_err_t api_sensor_status_handler(httpd_req_t *req)
{
    uint8_t address;
    if (!parse_sensor_address_from_uri(req->uri, SENSOR_STATUS_URI, &address)) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid sensor address");
        return ESP_FAIL;
    }

    ezo_sensor_t *sensor = find_sensor_by_address(address);
    if (sensor == NULL) {
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "Sensor not found");
        return ESP_FAIL;
    }

    sensor_read_guard_t guard;
    sensor_read_guard_acquire(&guard);

    esp_err_t refresh = ezo_sensor_refresh_settings(sensor);
    if (refresh != ESP_OK) {
        ESP_LOGW(TAG, "Failed to refresh sensor %02X before status read: %s", address, esp_err_to_name(refresh));
    }

    cJSON *sensor_json = build_sensor_json(sensor, -1, true);
    if (sensor_json == NULL) {
        sensor_read_guard_release(&guard);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to serialize sensor");
        return ESP_FAIL;
    }

    const char *payload = cJSON_PrintUnformatted(sensor_json);
    cJSON_Delete(sensor_json);
    if (payload == NULL) {
        sensor_read_guard_release(&guard);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to serialize sensor");
        return ESP_FAIL;
    }

    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, payload);
    free((void*)payload);
    sensor_read_guard_release(&guard);
    return ESP_OK;
}

static esp_err_t api_sensor_sample_handler(httpd_req_t *req)
{
    uint8_t address;
    if (!parse_sensor_address_from_uri(req->uri, SENSOR_SAMPLE_URI, &address)) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid sensor address");
        return ESP_FAIL;
    }

    ezo_sensor_t *sensor = find_sensor_by_address(address);
    if (sensor == NULL) {
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "Sensor not found");
        return ESP_FAIL;
    }

    float values[4] = {0};
    uint8_t count = 0;

    sensor_read_guard_t guard;
    sensor_read_guard_acquire(&guard);
    esp_err_t ret = ezo_sensor_read_all(sensor, values, &count);
    sensor_read_guard_release(&guard);

    if (ret != ESP_OK || count == 0) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to read sensor");
        return ESP_FAIL;
    }

    cJSON *sensor_json = build_sensor_json(sensor, -1, true);
    if (sensor_json == NULL) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to serialize sensor");
        return ESP_FAIL;
    }

    uint64_t timestamp_ms = esp_timer_get_time() / 1000ULL;
    cJSON_AddNumberToObject(sensor_json, "timestamp_ms", (double)timestamp_ms);
    cJSON_AddNumberToObject(sensor_json, "value_count", count);

    cJSON *raw_array = cJSON_CreateArray();
    if (raw_array != NULL) {
        for (uint8_t i = 0; i < count; i++) {
            cJSON_AddItemToArray(raw_array, cJSON_CreateNumber(values[i]));
        }
        cJSON_AddItemToObject(sensor_json, "raw", raw_array);
    }

    add_sample_readings_to_json(sensor_json, sensor->config.type, values, count);

    cJSON *root = cJSON_CreateObject();
    if (root == NULL) {
        cJSON_Delete(sensor_json);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to allocate response");
        return ESP_FAIL;
    }

    cJSON_AddStringToObject(root, "status", "success");
    cJSON_AddItemToObject(root, "sensor", sensor_json);

    const char *payload = cJSON_PrintUnformatted(root);
    if (payload == NULL) {
        cJSON_Delete(root);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to encode response");
        return ESP_FAIL;
    }

    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, payload);
    free((void*)payload);
    cJSON_Delete(root);
    return ESP_OK;
}

// URI handlers
static const httpd_uri_t favicon_uri = {
    .uri = "/favicon.ico",
    .method = HTTP_GET,
    .handler = favicon_handler,
    .user_ctx = NULL
};

static const httpd_uri_t root_uri = {
    .uri = "/",
    .method = HTTP_GET,
    .handler = root_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_status_uri = {
    .uri = "/api/status",
    .method = HTTP_GET,
    .handler = api_status_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_clear_wifi_uri = {
    .uri = "/api/clear-wifi",
    .method = HTTP_POST,
    .handler = api_clear_wifi_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_reboot_uri = {
    .uri = "/api/reboot",
    .method = HTTP_POST,
    .handler = api_reboot_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_test_mqtt_uri = {
    .uri = "/api/test-mqtt",
    .method = HTTP_POST,
    .handler = api_test_mqtt_handler,
    .user_ctx = NULL
};

// Settings API - handles both GET and POST
static const httpd_uri_t api_settings_get_uri = {
    .uri = "/api/settings",
    .method = HTTP_GET,
    .handler = api_settings_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_settings_post_uri = {
    .uri = "/api/settings",
    .method = HTTP_POST,
    .handler = api_settings_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_settings_reset_uri = {
    .uri = "/api/settings/reset",
    .method = HTTP_POST,
    .handler = api_settings_reset_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_sensors_list_uri = {
    .uri = "/api/sensors",
    .method = HTTP_GET,
    .handler = api_sensors_list_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_sensors_rescan_uri = {
    .uri = "/api/sensors/rescan",
    .method = HTTP_POST,
    .handler = api_sensors_rescan_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_sensors_config_uri = {
    .uri = "/api/sensors/config",
    .method = HTTP_POST,
    .handler = api_sensors_config_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_sensors_pause_uri = {
    .uri = "/api/sensors/pause",
    .method = HTTP_POST,
    .handler = api_sensors_pause_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_sensors_resume_uri = {
    .uri = "/api/sensors/resume",
    .method = HTTP_POST,
    .handler = api_sensors_resume_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_sensor_calibrate_uri = {
    .uri = "/api/sensors/calibrate/*",
    .method = HTTP_POST,
    .handler = api_sensor_calibrate_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_sensor_comp_uri = {
    .uri = "/api/sensors/compensate/*",
    .method = HTTP_POST,
    .handler = api_sensor_compensation_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_sensor_mode_uri = {
    .uri = "/api/sensors/mode/*",
    .method = HTTP_POST,
    .handler = api_sensor_mode_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_sensor_power_uri = {
    .uri = "/api/sensors/power/*",
    .method = HTTP_POST,
    .handler = api_sensor_power_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_sensor_status_uri = {
    .uri = "/api/sensors/status/*",
    .method = HTTP_GET,
    .handler = api_sensor_status_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_sensor_sample_uri = {
    .uri = "/api/sensors/sample/*",
    .method = HTTP_GET,
    .handler = api_sensor_sample_handler,
    .user_ctx = NULL
};

/**
 * @brief List web files API handler
 */
static esp_err_t api_webfiles_list_handler(httpd_req_t *req)
{
    char *json = NULL;
    if (web_editor_list_files(&json) == ESP_OK) {
        httpd_resp_set_type(req, "application/json");
        httpd_resp_send(req, json, HTTPD_RESP_USE_STRLEN);
        free(json);
        return ESP_OK;
    }
    httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to list files");
    return ESP_FAIL;
}

/**
 * @brief Get web file content API handler
 */
static esp_err_t api_webfiles_get_handler(httpd_req_t *req)
{
    // Extract filename from URI (e.g., /api/webfiles/index.html)
    const char *filename = req->uri + strlen("/api/webfiles/");
    
    ESP_LOGI(TAG, "GET handler called for file: %s", filename);
    
    char *content = NULL;
    size_t size = 0;
    esp_err_t ret = web_editor_load_file(filename, &content, &size);
    
    if (ret == ESP_OK) {
        httpd_resp_set_type(req, web_editor_get_content_type(filename));
        httpd_resp_send(req, content, size);
        free(content);
        return ESP_OK;
    }
    httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "File not found");
    return ESP_FAIL;
}

/**
 * @brief Save web file content API handler
 */
static esp_err_t api_webfiles_put_handler(httpd_req_t *req)
{
    // Extract filename from URI (e.g., /api/webfiles/index.html)
    const char *filename = req->uri + strlen("/api/webfiles/");
    
    // Read request body (allocate from PSRAM first to avoid IRAM fragmentation)
    char *content = heap_caps_malloc(WEB_EDITOR_MAX_FILE_SIZE, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
    if (content == NULL) {
        content = malloc(WEB_EDITOR_MAX_FILE_SIZE);
    }
    if (content == NULL) {
        ESP_LOGE(TAG, "webfiles PUT: failed to allocate %d bytes", WEB_EDITOR_MAX_FILE_SIZE);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Out of memory");
        return ESP_FAIL;
    }
    
    int total_len = 0;
    int received;
    while (total_len < req->content_len && total_len < WEB_EDITOR_MAX_FILE_SIZE) {
        size_t bytes_to_read = req->content_len - total_len;
        if (bytes_to_read > WEB_EDITOR_MAX_FILE_SIZE - total_len) {
            bytes_to_read = WEB_EDITOR_MAX_FILE_SIZE - total_len;
        }
        received = httpd_req_recv(req, content + total_len, bytes_to_read);
        if (received <= 0) {
            free(content);
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to read request");
            return ESP_FAIL;
        }
        total_len += received;
    }
    
    if (total_len == WEB_EDITOR_MAX_FILE_SIZE && total_len < req->content_len) {
        free(content);
        httpd_resp_send_err(req, HTTPD_413_CONTENT_TOO_LARGE, "File exceeds 200KB limit");
        return ESP_FAIL;
    }
    
    // Persist to on-device filesystem
    esp_err_t ret = web_editor_save_file(filename, content, total_len);
    free(content);
    
    if (ret == ESP_OK) {
        httpd_resp_set_type(req, "application/json");
        httpd_resp_sendstr(req, "{\"success\":true}");
        return ESP_OK;
    }
    httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to save file");
    return ESP_FAIL;
}

static esp_err_t api_webfiles_reset_handler(httpd_req_t *req)
{
    esp_err_t err = web_editor_reset_fs();
    if (err == ESP_OK) {
        httpd_resp_set_type(req, "application/json");
        httpd_resp_sendstr(req, "{\"success\":true,\"message\":\"filesystem reset\"}");
        return ESP_OK;
    }

    char msg[80];
    snprintf(msg, sizeof(msg), "Reset failed (%s)", esp_err_to_name(err));
    httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, msg);
    return ESP_FAIL;
}

static const httpd_uri_t api_webfiles_list_uri = {
    .uri = "/api/webfiles/list",
    .method = HTTP_GET,
    .handler = api_webfiles_list_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_webfiles_get_uri = {
    .uri = "/api/webfiles/*",
    .method = HTTP_GET,
    .handler = api_webfiles_get_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_webfiles_put_uri = {
    .uri = "/api/webfiles/*",
    .method = HTTP_PUT,
    .handler = api_webfiles_put_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_webfiles_reset_uri = {
    .uri = "/api/webfiles/reset",
    .method = HTTP_POST,
    .handler = api_webfiles_reset_handler,
    .user_ctx = NULL
};

static void ota_reboot_task(void *arg)
{
    vTaskDelay(pdMS_TO_TICKS(1500));
    esp_restart();
}

static void schedule_ota_reboot(void)
{
    BaseType_t created = xTaskCreate(ota_reboot_task, "ota_reboot", 2048, NULL, 5, NULL);
    if (created != pdPASS) {
        ESP_LOGE(TAG, "Failed to create OTA reboot task");
    }
}

static esp_err_t api_firmware_upload_handler(httpd_req_t *req)
{
    if (req->content_len <= 0) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "No firmware provided");
        return ESP_FAIL;
    }

    const esp_partition_t *update_partition = esp_ota_get_next_update_partition(NULL);
    if (update_partition == NULL) {
        ESP_LOGE(TAG, "No OTA partition available");
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "OTA partition missing");
        return ESP_FAIL;
    }

    if (req->content_len > update_partition->size) {
        ESP_LOGW(TAG, "Firmware image too large: %d (max %d)", req->content_len, update_partition->size);
        httpd_resp_send_err(req, HTTPD_413_CONTENT_TOO_LARGE, "Firmware image too large");
        return ESP_FAIL;
    }

    esp_ota_handle_t ota_handle = 0;
    esp_err_t err = esp_ota_begin(update_partition, req->content_len, &ota_handle);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "esp_ota_begin failed: %s", esp_err_to_name(err));
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to start OTA");
        return ESP_FAIL;
    }

    uint8_t *ota_buffer = heap_caps_malloc(OTA_UPLOAD_BUFFER_SIZE, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
    if (ota_buffer == NULL) {
        ota_buffer = malloc(OTA_UPLOAD_BUFFER_SIZE);
    }
    if (ota_buffer == NULL) {
        ESP_LOGE(TAG, "Failed to allocate OTA buffer");
        esp_ota_abort(ota_handle);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Out of memory");
        return ESP_FAIL;
    }

    int remaining = req->content_len;
    while (remaining > 0) {
        int chunk = remaining > OTA_UPLOAD_BUFFER_SIZE ? OTA_UPLOAD_BUFFER_SIZE : remaining;
        int received = httpd_req_recv(req, (char *)ota_buffer, chunk);
        if (received <= 0) {
            if (received == HTTPD_SOCK_ERR_TIMEOUT) {
                continue;
            }
            ESP_LOGE(TAG, "OTA upload interrupted (%d)", received);
            free(ota_buffer);
            esp_ota_abort(ota_handle);
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Upload interrupted");
            return ESP_FAIL;
        }

        err = esp_ota_write(ota_handle, ota_buffer, received);
        if (err != ESP_OK) {
            ESP_LOGE(TAG, "esp_ota_write failed: %s", esp_err_to_name(err));
            free(ota_buffer);
            esp_ota_abort(ota_handle);
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Flash write failed");
            return ESP_FAIL;
        }
        remaining -= received;
    }

    free(ota_buffer);

    err = esp_ota_end(ota_handle);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "esp_ota_end failed: %s", esp_err_to_name(err));
        esp_ota_abort(ota_handle);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "OTA finalize failed");
        return ESP_FAIL;
    }

    err = esp_ota_set_boot_partition(update_partition);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to set boot partition: %s", esp_err_to_name(err));
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to set boot partition");
        return ESP_FAIL;
    }

    ESP_LOGI(TAG, "Firmware uploaded successfully (%d bytes)", req->content_len);

    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"status\":\"uploaded\",\"reboot\":true}");

    schedule_ota_reboot();
    return ESP_OK;
}

static const httpd_uri_t api_firmware_upload_uri = {
    .uri = "/api/firmware/upload",
    .method = HTTP_POST,
    .handler = api_firmware_upload_handler,
    .user_ctx = NULL
};

/**
 * @brief Handler for CA certificate download
 */
static esp_err_t ca_cert_handler(httpd_req_t *req)
{
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open_from_partition("https", "https", NVS_READONLY, &nvs_handle);
    if (err != ESP_OK) {
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "CA certificate not found");
        return ESP_FAIL;
    }
    
    size_t ca_cert_len = 0;
    err = nvs_get_str(nvs_handle, "ca_cert", NULL, &ca_cert_len);
    if (err != ESP_OK || ca_cert_len == 0) {
        nvs_close(nvs_handle);
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "CA certificate not available");
        return ESP_FAIL;
    }
    
    char *ca_cert = malloc(ca_cert_len);
    if (ca_cert == NULL) {
        nvs_close(nvs_handle);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Out of memory");
        return ESP_FAIL;
    }
    
    err = nvs_get_str(nvs_handle, "ca_cert", ca_cert, &ca_cert_len);
    nvs_close(nvs_handle);
    
    if (err != ESP_OK) {
        free(ca_cert);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to read CA certificate");
        return ESP_FAIL;
    }
    
    // Set content type and disposition for download
    httpd_resp_set_type(req, "application/x-pem-file");
    httpd_resp_set_hdr(req, "Content-Disposition", "attachment; filename=\"kannacloud-ca.crt\"");
    
    httpd_resp_send(req, ca_cert, ca_cert_len - 1);
    free(ca_cert);
    
    return ESP_OK;
}

static const httpd_uri_t ca_cert_uri = {
    .uri = "/ca.crt",
    .method = HTTP_GET,
    .handler = ca_cert_handler,
    .user_ctx = NULL
};

static const httpd_uri_t sensor_ws_uri = {
    .uri = SENSOR_WS_URI,
    .method = HTTP_GET,
    .handler = sensor_ws_handler,
    .user_ctx = NULL,
    .is_websocket = true
};

esp_err_t http_server_start(void)
{
    if (s_server != NULL) {
        ESP_LOGW(TAG, "HTTPS server already running");
        return ESP_OK;
    }
    
    // Initialize FATFS-backed dashboard storage
    web_editor_init_fs();
    
    ESP_LOGI(TAG, "Starting HTTPS server...");
    
    // Get certificates from cloud provisioning
    char *certificate = malloc(CLOUD_PROV_MAX_CERT_SIZE);
    char *private_key = malloc(CLOUD_PROV_MAX_KEY_SIZE);
    
    if (certificate == NULL || private_key == NULL) {
        ESP_LOGE(TAG, "Failed to allocate memory for certificates");
        free(certificate);
        free(private_key);
        return ESP_ERR_NO_MEM;
    }
    
    size_t cert_len, key_len;
    esp_err_t err = cloud_prov_get_certificate(certificate, &cert_len);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to get certificate: %s", esp_err_to_name(err));
        free(certificate);
        free(private_key);
        return err;
    }
    
    err = cloud_prov_get_private_key(private_key, &key_len);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to get private key: %s", esp_err_to_name(err));
        free(certificate);
        free(private_key);
        return err;
    }
    
    ESP_LOGI(TAG, "Certificate length: %zu bytes", cert_len);
    ESP_LOGI(TAG, "Private key length: %zu bytes", key_len);
    
    // Debug certificate format
    ESP_LOGI(TAG, "Cert first 100 chars: %.100s", certificate);
    if (cert_len > 100) {
        ESP_LOGI(TAG, "Cert last 100 chars: %s", certificate + cert_len - 100);
    }
    
    // Configure HTTPS server
    httpd_ssl_config_t config = HTTPD_SSL_CONFIG_DEFAULT();
    config.httpd.max_uri_handlers = 30;  // Increased for web file editor + sensor action endpoints
    config.httpd.stack_size = 8192;  // Reduced stack to save memory
    config.httpd.max_open_sockets = 3;  // Allow multiple connections now that PSRAM is enabled
    config.httpd.lru_purge_enable = true;  // Enable automatic cleanup of old connections
    config.httpd.close_fn = NULL;  // Use default close function
    config.httpd.recv_wait_timeout = 30;  // Increased timeout for SSL handshake (was 10)
    config.httpd.send_wait_timeout = 30;  // Increased timeout for SSL handshake (was 10)
    config.port_insecure = 0;  // Disable insecure port (HTTPS only)
    config.httpd.uri_match_fn = httpd_uri_match_wildcard;  // Enable wildcard URI matching
    
    // Set certificates (PEM format from NVS is already null-terminated)
    // mbedTLS needs length + 1 to include the null terminator
    config.servercert = (const uint8_t *)certificate;
    config.servercert_len = cert_len + 1;
    config.prvtkey_pem = (const uint8_t *)private_key;
    config.prvtkey_len = key_len + 1;
    
    // Skip client certificate verification (allows browsers to connect without trusting cert)
    config.session_tickets = false;  // Disable session resumption for testing
    config.use_secure_element = false;  // Not using hardware secure element
    
    // Start server
    err = httpd_ssl_start(&s_server, &config);
    
    // Clean up certificate buffers
    free(certificate);
    free(private_key);
    
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to start HTTPS server: %s", esp_err_to_name(err));
        return err;
    }
    
    // Register URI handlers
    httpd_register_uri_handler(s_server, &favicon_uri);
    httpd_register_uri_handler(s_server, &root_uri);
    httpd_register_uri_handler(s_server, &sensor_ws_uri);
    httpd_register_uri_handler(s_server, &ca_cert_uri);  // CA certificate download
    httpd_register_uri_handler(s_server, &api_status_uri);
    httpd_register_uri_handler(s_server, &api_clear_wifi_uri);
    httpd_register_uri_handler(s_server, &api_reboot_uri);
    httpd_register_uri_handler(s_server, &api_test_mqtt_uri);
    httpd_register_uri_handler(s_server, &api_settings_get_uri);
    httpd_register_uri_handler(s_server, &api_settings_post_uri);
    httpd_register_uri_handler(s_server, &api_settings_reset_uri);
    httpd_register_uri_handler(s_server, &api_sensors_list_uri);
    httpd_register_uri_handler(s_server, &api_sensors_rescan_uri);
    httpd_register_uri_handler(s_server, &api_sensors_config_uri);
    httpd_register_uri_handler(s_server, &api_sensors_pause_uri);
    httpd_register_uri_handler(s_server, &api_sensors_resume_uri);
    httpd_register_uri_handler(s_server, &api_sensor_calibrate_uri);
    httpd_register_uri_handler(s_server, &api_sensor_comp_uri);
    httpd_register_uri_handler(s_server, &api_sensor_mode_uri);
    httpd_register_uri_handler(s_server, &api_sensor_power_uri);
    httpd_register_uri_handler(s_server, &api_sensor_status_uri);
    httpd_register_uri_handler(s_server, &api_sensor_sample_uri);
    // Register specific list endpoint before wildcard catch-alls so /list is handled correctly
    httpd_register_uri_handler(s_server, &api_webfiles_list_uri);
    httpd_register_uri_handler(s_server, &api_webfiles_reset_uri);
    httpd_register_uri_handler(s_server, &api_webfiles_get_uri);
    httpd_register_uri_handler(s_server, &api_webfiles_put_uri);
    httpd_register_uri_handler(s_server, &api_firmware_upload_uri);
    
    sensor_manager_register_cache_listener(handle_sensor_cache_update, NULL);

    ESP_LOGI(TAG, " HTTPS server started successfully");
    ESP_LOGI(TAG, "Dashboard accessible at: https://kc.local");
    ESP_LOGI(TAG, "Registered sensor + dashboard API endpoints");
    
    return ESP_OK;
}

esp_err_t http_server_stop(void)
{
    if (s_server == NULL) {
        return ESP_OK;
    }
    
    sensor_manager_register_cache_listener(NULL, NULL);
    focus_stream_stop();
    if (s_focus_timer != NULL) {
        esp_timer_delete(s_focus_timer);
        s_focus_timer = NULL;
    }
    if (s_ws_clients_mutex != NULL) {
        if (xSemaphoreTake(s_ws_clients_mutex, pdMS_TO_TICKS(50)) == pdTRUE) {
            for (int i = 0; i < SENSOR_WS_MAX_CLIENTS; i++) {
                s_ws_clients[i].active = false;
                s_ws_clients[i].fd = -1;
            }
            xSemaphoreGive(s_ws_clients_mutex);
        }
    }

    ESP_LOGI(TAG, "Stopping HTTPS server");
    httpd_ssl_stop(s_server);
    s_server = NULL;
    
    return ESP_OK;
}

bool http_server_is_running(void)
{
    return (s_server != NULL);
}

#else
// ESP32-C6: Stub implementations (no local dashboard)

esp_err_t http_server_start(void)
{
    ESP_LOGW(TAG, "HTTP server not available on ESP32-C6 (cloud-only mode)");
    return ESP_ERR_NOT_SUPPORTED;
}

esp_err_t http_server_stop(void)
{
    return ESP_OK;
}

bool http_server_is_running(void)
{
    return false;
}

#endif // CONFIG_IDF_TARGET_ESP32C6
